<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ASCII Camera Glitch</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background-color: #000;
    }
    canvas {
      display: block;
      position: absolute;
      top: 0;
      left: 0;
    }
  </style>
</head>
<body>
  <main></main>
  <script>
    let cam;
    let cellSize = 12;
    let cols, rows;
    let grid;
    let pg; // Graphics buffer for better performance

    const asciiChars = " .:AkerBP";
    let fadeAmount = 15;

    let lastGlitchTime = 0;
    let glitchInterval = 5000;
    let isGlitching = false;
    let glitchDuration = 0;
    let glitchType = 0;

    // Performance optimization
    let framesSinceStart = 0;
    let performanceCheckDone = false;
    const TARGET_FPS = 25;
    const PERFORMANCE_CHECK_INTERVAL = 30; // Check every 30 frames
    const MAX_ADJUSTMENTS = 5; // Stop after 5 adjustments
    let adjustmentCount = 0;

    function setup() {
      createCanvas(windowWidth, windowHeight);
      pixelDensity(1); // Reduce pixel density for better performance

      cam = createCapture(VIDEO);
      cam.size(640, 480); // Lower resolution for performance
      cam.hide();

      updateGrid();

      textAlign(CENTER, CENTER);
      textFont('monospace'); // Use monospace for consistent ASCII rendering
      background(0);
      frameRate(60);
    }

    function draw() {
      if (cam.loadedmetadata) {
        // Performance check and auto-adjust
        if (!performanceCheckDone) {
          framesSinceStart++;
          if (framesSinceStart % PERFORMANCE_CHECK_INTERVAL === 0) {
            const currentFPS = frameRate();
            if (currentFPS < TARGET_FPS && adjustmentCount < MAX_ADJUSTMENTS) {
              // Increase cell size to reduce number of cells
              const adjustment = map(currentFPS, 5, TARGET_FPS, 6, 2);
              cellSize = constrain(cellSize + adjustment, 8, 40);
              updateGrid();
              adjustmentCount++;
              console.log(`Auto-adjusted cell size to ${cellSize} (FPS: ${currentFPS.toFixed(1)})`);
            } else if (currentFPS >= TARGET_FPS || adjustmentCount >= MAX_ADJUSTMENTS) {
              performanceCheckDone = true;
              console.log(`Performance check complete. Final cell size: ${cellSize}, FPS: ${currentFPS.toFixed(1)}`);
            }
          }
        }

        // Check for random glitch event
        if (millis() - lastGlitchTime > glitchInterval && !isGlitching) {
          if (random(1) < 0.3) {
            isGlitching = true;
            glitchDuration = int(random(10, 30));
            glitchType = int(random(3));
            lastGlitchTime = millis();
          }
        }

        if (isGlitching) {
          glitchDuration--;
          if (glitchDuration <= 0) {
            isGlitching = false;
          }
        }

        // Optimized trail effect
        noStroke();
        fill(0, fadeAmount);
        rect(0, 0, width, height);

        const magenta = color(219, 10, 91);
        const cyan = color(23, 190, 157);
        const orange = color(255, 152, 48);

        cam.loadPixels();

        // Calculate aspect ratios (cache these values)
        const camAspect = cam.width / cam.height;
        const canvasAspect = width / height;

        // Calculate scale to fill canvas while maintaining aspect ratio
        let scale, offsetX, offsetY;
        if (canvasAspect > camAspect) {
          scale = width / cam.width;
          offsetX = 0;
          offsetY = (height - cam.height * scale) / 2;
        } else {
          scale = height / cam.height;
          offsetX = (width - cam.width * scale) / 2;
          offsetY = 0;
        }

        // Cache frequently used values
        const camWidth = cam.width;
        const camPixels = cam.pixels;

        for (let i = 0; i < cols; i++) {
          for (let j = 0; j < rows; j++) {
            const mirrorI = cols - 1 - i;
            const x = mirrorI * cellSize + cellSize / 2;
            const y = j * cellSize + cellSize / 2;

            let glitchOffsetX = 0;
            let glitchOffsetY = 0;
            if (isGlitching && glitchType === 0) {
              glitchOffsetX = random(-20, 20);
            } else if (isGlitching && glitchType === 1) {
              glitchOffsetY = sin(j * 0.5 + frameCount * 0.5) * 10;
            }

            // Map canvas coordinates to camera coordinates
            const camX = (x - offsetX) / scale;
            const camY = (y - offsetY) / scale;

            const px = constrain(floor(camX), 0, cam.width - 1);
            const py = constrain(floor(camY), 0, cam.height - 1);
            const pixelIndex = (px + py * camWidth) * 4;

            if (pixelIndex < camPixels.length) {
              const r = camPixels[pixelIndex];
              const g = camPixels[pixelIndex + 1];
              const b = camPixels[pixelIndex + 2];
              const brightness = (r + g + b) * 0.333; // Slightly faster than division

              grid[i][j].update(brightness);
              grid[i][j].display(
                i * cellSize + cellSize / 2 + glitchOffsetX,
                y + glitchOffsetY,
                cellSize,
                magenta,
                cyan,
                orange,
                isGlitching,
                glitchType
              );
            }
          }
        }

        // UI with background blur effect
        const trailMode = fadeAmount === 15 ? "short" : "long";
        const randomMode = grid[0][0].randomAmount < 0.15 ? "low" : (grid[0][0].randomAmount < 0.35 ? "med" : "high");
        const uiText = `FPS: ${int(frameRate())} | B = bigger | S = smaller | T = trails (${trailMode}) | R = random (${randomMode})`;
        const uiX = 10;
        const uiY = 20;
        const uiPadding = 8;

        textAlign(LEFT, TOP);
        textSize(12);
        const textW = textWidth(uiText);
        const textH = 12;

        // Semi-transparent background box with slight blur effect
        fill(0, 150);
        noStroke();
        rect(uiX - uiPadding, uiY - uiPadding, textW + uiPadding * 2, textH + uiPadding * 2, 4);

        // Draw UI text
        fill(255, 255);
        text(uiText, uiX, uiY);
      }
    }

    class TrailCell {
      constructor() {
        this.smoothedBrightness = 0;
        this.displayBrightness = 0;
        this.randomAmount = 0.12;
        this.isBlock = false;
        this.blockTimer = 0;
        this.blockOffsetX = 0;
        this.blockOffsetY = 0;
        this.blockVelX = 0;
        this.blockVelY = 0;
      }

      update(newBrightness) {
        this.smoothedBrightness = lerp(this.smoothedBrightness, newBrightness, 0.4);
        this.displayBrightness = this.smoothedBrightness;

        if (random(1) < 0.00008) {
          this.isBlock = true;
          this.blockTimer = int(random(30, 60));
          this.blockOffsetX = 0;
          this.blockOffsetY = 0;
          this.blockVelX = random(-0.3, 0.3);
          this.blockVelY = random(-0.3, 0.3);
        }

        if (this.isBlock) {
          this.blockOffsetX += this.blockVelX;
          this.blockOffsetY += this.blockVelY;
          this.blockTimer--;
          if (this.blockTimer <= 0) {
            this.isBlock = false;
          }
        }
      }

      display(x, y, size, magenta, cyan, orange, glitching, gType) {
        // Optimized color calculation
        const b = this.displayBrightness;
        let displayColor;
        if (b < 85) {
          displayColor = magenta;
        } else if (b < 170) {
          const amt = (b - 85) / 85; // Faster than map()
          displayColor = lerpColor(magenta, cyan, amt);
        } else {
          const amt = (b - 170) / 85; // Faster than map()
          displayColor = lerpColor(cyan, orange, amt);
        }

        if (glitching && gType === 2 && random(1) < 0.3) {
          const r = red(displayColor);
          const g = green(displayColor);
          const bl = blue(displayColor);
          displayColor = color(bl, r, g);
        }

        let alpha = 120 + (b * 0.529); // Optimized map(b, 0, 255, 120, 255)
        if (glitching) alpha = min(alpha + 50, 255);

        if (this.isBlock) {
          fill(red(displayColor), green(displayColor), blue(displayColor), alpha);
          noStroke();
          rectMode(CENTER);
          rect(x + this.blockOffsetX, y + this.blockOffsetY, size * 0.9, size * 0.9);
          rectMode(CORNER);
        } else {
          // Optimized character selection
          let charIndex = floor(b / 255 * (asciiChars.length - 1));
          charIndex = constrain(charIndex, 0, asciiChars.length - 1);
          let displayChar = asciiChars.charAt(charIndex);

          if (b < 80 && random(1) < this.randomAmount) {
            const randomRange = 2;
            let randomIdx = charIndex + int(random(-randomRange, randomRange + 1));
            randomIdx = constrain(randomIdx, 0, asciiChars.length - 1);
            displayChar = asciiChars.charAt(randomIdx);
          }

          if (glitching && random(1) < 0.4) {
            displayChar = asciiChars.charAt(int(random(asciiChars.length)));
          }

          fill(red(displayColor), green(displayColor), blue(displayColor), alpha);
          textSize(size);
          text(displayChar, x, y);
        }
      }

      setRandomAmount(amt) {
        this.randomAmount = amt;
      }
    }

    function keyPressed() {
      if (key === 'b' || key === 'B') {
        cellSize = constrain(cellSize + 2, 6, 40);
        updateGrid();
      } else if (key === 's' || key === 'S') {
        cellSize = constrain(cellSize - 2, 6, 40);
        updateGrid();
      } else if (key === 't' || key === 'T') {
        fadeAmount = (fadeAmount === 15) ? 40 : 15;
      } else if (key === 'r' || key === 'R') {
        let newRandom = grid[0][0].randomAmount;
        if (newRandom < 0.15) newRandom = 0.3;
        else if (newRandom < 0.35) newRandom = 0.6;
        else newRandom = 0.12;

        for (let i = 0; i < cols; i++) {
          for (let j = 0; j < rows; j++) {
            grid[i][j].setRandomAmount(newRandom);
          }
        }
      }
    }

    function updateGrid() {
      cols = floor(width / cellSize);
      rows = floor(height / cellSize);
      const newGrid = [];

      for (let i = 0; i < cols; i++) {
        newGrid[i] = [];
        for (let j = 0; j < rows; j++) {
          newGrid[i][j] = new TrailCell();

          if (grid) {
            const oldI = floor(map(i, 0, cols, 0, grid.length));
            const oldJ = floor(map(j, 0, rows, 0, grid[0].length));
            if (oldI < grid.length && oldJ < grid[0].length) {
              newGrid[i][j].smoothedBrightness = grid[oldI][oldJ].smoothedBrightness;
              newGrid[i][j].displayBrightness = grid[oldI][oldJ].displayBrightness;
              newGrid[i][j].randomAmount = grid[oldI][oldJ].randomAmount;
            }
          }
        }
      }

      grid = newGrid;
    }

    function windowResized() {
      resizeCanvas(windowWidth, windowHeight);
      updateGrid();
    }
  </script>
</body>
</html>
